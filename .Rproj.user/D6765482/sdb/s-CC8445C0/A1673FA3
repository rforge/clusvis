{
    "collab_server" : "",
    "contents" : "###################################################################################\n##' Function for visualizing the clustering results\n##'\n##' @param res object return by function \\link{clusvis} or \\link{clusvis}\n##' @param dim   numeric. This vector of size two choose the axes to represent.\n##' @param threshold   numeric. It contains the thersholds used for computing the level curves.\n##' @param add.obs   boolean. If TRUE, coordinnates of the observations are plotted.\n##' @param positionlegend  character. It specifies the legend location.\n##' @param xlim  numeric. It specifies the range of x-axis.\n##' @param ylim  numeric. It specifies the range of y-axis.\n##'\n##'\n##' @return NULL\n##' @examples\n##' # Package loading\n##' require(Rmixmod)\n##' \n##' # Data loading (categorical data)\n##' data(birds)\n##'\n##' # Model-based clustering with 3 components\n##' resmixmod <- mixmodCluster(birds, 3)\n##'\n##' # Inference of the parameters used for results visualization\n##' # (specific for Rmixmod results)\n##' resvisu <- clusvisMixmod(resmixmod)\n##'\n##' # Component interpretation graph\n##' plotDensityClusVisu(resvisu)\n##'\n##' # Scatter-plot of the observation memberships\n##' plotDensityClusVisu(resvisu,  add.obs = TRUE)\n##' @export\n##'\nplotDensityClusVisu <- function(res,\n                                dim=c(1,2),\n                                threshold=0.95,\n                                add.obs=FALSE,\n                                positionlegend=\"topright\",\n                                xlim=NULL,\n                                ylim=NULL){\n  if (add.obs){\n    input <- list()\n    if (is.null(xlim)) xlim <- c(min(c(res$centers[,dim[1]], res$y[,dim[1]]))-1, max(c(res$centers[,dim[1]], res$y[,dim[1]])) + 1)\n    if (is.null(ylim)) ylim <- c(min(c(res$centers[,dim[2]], res$y[,dim[2]]))-1, max(c(res$centers[,dim[2]], res$y[,dim[2]])) + 1)\n    input$xval <- seq(xlim[1], xlim[2], length.out = 400)\n    input$yval <- seq(ylim[1], ylim[2], length.out = 400)\n    tmp <- sapply(1:length(res$prop), function(k) as.numeric(outer(input$xval, input$yval, dmixtmvnorm, mu=res$centers[k,dim], prop=res$prop[k])))\n    input$z  <- t(matrix(rowSums(tmp), length(input$xval), length(input$yval)))\n    input$z <- (matrix(apply(sweep(tmp, 1, rowSums(tmp), \"/\"), 1, max), length(input$xval), length(input$yval)))\n    input$z[which(input$z<0.55)] <- 0.4\n    contour(input,\n            main = paste0(\"Difference between entropies: \", round(res$EM - res$EV,2)),\n            levels=c(0.95,0.8,0.5),\n            col=c(\"gray30\",\"gray30\",1),\n            lwd=c(1,1,2),\n            lty=c(2,2,1),\n            labcex = 0.8,\n            xlab=paste0(\"Dim1 (\", 100*round(res$inertia[dim[1]]/sum(res$inertia), 4), \"%)\"),\n            ylab=paste0(\"Dim2 (\", 100*round(res$inertia[dim[2]]/sum(res$inertia), 4), \"%)\"))\n    colset <- c(\"darkorange1\", \"dodgerblue2\", \"black\", \"chartreuse2\", \"darkorchid2\", \"gold2\", \"deeppink2\", \"deepskyblue1\", \"firebrick2\", \"cyan1\")\n    if (length(colset) < ncol(res$logtik.obs)) colset <- rep(\"black\", ncol(res$logtik.obs))\n    # text(res$y[,dim[1]],\n    #      res$y[,dim[2]],\n    #      as.character(apply(res$logtik.obs, 1, which.max)),\n    #      cex=0.6,\n    #      lwd=1.2,\n    #      col=colset[apply(res$logtik.obs, 1, which.max)])\n    points(res$y[,dim[1]],\n         res$y[,dim[2]],\n         pch=20,\n         cex=0.7,\n         col=colset[apply(res$logtik.obs, 1, which.max)])\n    if (length(colset) >= ncol(res$logtik.obs)) legend(x = positionlegend, legend = paste0(\"Compo.\", 1:ncol(res$logtik.obs)), col = colset[1:ncol(res$logtik.obs)], pch = 20)\n\n\n  }else{\n    if (is.null(xlim)) xlim <- c(min(res$centers[,dim[1]])-4, max(res$centers[,dim[1]]) + 4)\n    if (is.null(ylim)) ylim <- c(min(res$centers[,dim[2]])-4, max(res$centers[,dim[2]]) + 4)\n    xval <- seq(xlim[1], xlim[2], length.out = 400)\n    yval <- seq(ylim[1], ylim[2], length.out = 400)\n    tmp <- sapply(1:length(res$prop), function(k) as.numeric(outer(xval, yval, dmixtmvnorm, mu=res$centers[k,dim], prop=res$prop[k])))\n    z <- t(matrix(rowSums(tmp), length(xval), length(yval)))\n    tikmax <- t(matrix(apply(sweep(tmp, 1, rowSums(tmp), \"/\"), 1, max), length(xval), length(yval)))\n    class <- t(matrix(apply(sweep(tmp, 1, rowSums(tmp), \"/\"), 1, which.max), length(xval), length(yval)))\n    tmp <- optimize(function(alpha, z, threshold) abs(sum(z*(z>alpha))/sum(z) - threshold),\n                    interval = c(0, max(z)),\n                    z=z,\n                    threshold=threshold)\n    bound <- min(as.numeric(tikmax)[which(as.numeric(z)>tmp$minimum)])\n\n    tikmax <- tikmax *(z>tmp$minimum)\n    image(xval,yval,t(tikmax),\n          main =  paste0(\"Difference between entropies: \", round(res$EM - res$EV,2)),\n          col=c(\"white\",\"gray30\",\"gray60\",\"gray80\"), breaks = c(0,0.001,0.8,0.95,1),\n          xlab=paste0(\"Dim1 (\", 100*round(res$inertia[dim[1]]/sum(res$inertia), 4), \"%)\"),\n          ylab=paste0(\"Dim2 (\", 100*round(res$inertia[dim[2]]/sum(res$inertia), 4), \"%)\")\n    )\n    legend(legend = c(\"0.95<Pr. Classif.\", \"0.8<Pr. Classif.<0.95\", \"Pr. Classif.<0.8\", \"outside the conf. level.\"), x = positionlegend, fill = c(\"gray80\",\"gray60\",\"gray30\", \"white\"), cex=0.7)\n    input <- list(x=xval, y=yval, z=t(tikmax))\n\n    contour(input, add=TRUE, levels=c(0.95,0.8,0.001), drawlabels = F,\n            lwd=c(1,1,2),\n            lty=c(2,2,1),\n            labcex = 0.8)\n    text(res$centers[,dim[1]], res$centers[,dim[2]], as.character(1:nrow(res$centers)), lwd=1.2)\n  }\n}\n  #\n  # plotDensityClusVisu <- function(res,\n  #                                 dim=c(1,2),\n  #                                 threshold=0.95,\n  #                                 add.obs=FALSE,\n  #                                 add.iso=1-add.obs){\n  #   xval <- seq(min(c(res$centers[,dim[1]], res$y[,dim[1]]))-4, max(c(res$centers[,dim[1]], res$y[,dim[1]])) + 4, length.out = 200)\n  #   yval <- seq(min(c(res$centers[,dim[2]], res$y[,dim[2]]))-4, max(c(res$centers[,dim[2]], res$y[,dim[2]])) + 4, length.out = 200)\n  #\n  #   tmp <- sapply(1:length(res$prop), function(k) as.numeric(outer(xval, yval, dmixtmvnorm, mu=res$centers[k,dim], prop=res$prop[k])))\n  #   z <- t(matrix(rowSums(tmp), length(xval), length(yval)))\n  #   tikmax <- t(matrix(apply(sweep(tmp, 1, rowSums(tmp), \"/\"), 1, max), length(xval), length(yval)))\n  #   class <- t(matrix(apply(sweep(tmp, 1, rowSums(tmp), \"/\"), 1, which.max), length(xval), length(yval)))\n  #   tmp <- optimize(function(alpha, z, threshold) abs(sum(z*(z>alpha))/sum(z) - threshold),\n  #                   interval = c(0, max(z)),\n  #                   z=z,\n  #                   threshold=threshold)\n  #   bound <- min(as.numeric(tikmax)[which(as.numeric(z)>tmp$minimum)])\n  #\n  #   areatik <- (tikmax<threshold) * 0.5\n  #\n  #   f <- list(\n  #     family = \"sans serif\",\n  #     size = 14,\n  #     color = \"black\"\n  #   )\n  #\n  #   xaxis <- list(\n  #     title = paste0(\"Dim1 (\", 100*round(res$inertia[dim[1]]/sum(res$inertia), 4), \"%)\"),\n  #     titlefont = f\n  #   )\n  #   yaxis <- list(\n  #     title = paste0(\"Dim2 (\", 100*round(res$inertia[dim[2]]/sum(res$inertia), 4), \"%)\"),\n  #     titlefont = f\n  #   )\n  #   p <- plot_ly(data=as.data.frame(res$y), showlegend=FALSE) %>%\n  #     add_contour(z = areatik,\n  #                 x=xval,\n  #                 y=yval,\n  #                 colors = colorRamp(c(\"white\", \"grey60\")),\n  #                 hoverinfo = 'text',\n  #                 ncontours = 20,\n  #                 showscale=FALSE ,\n  #                 line=list(color=\"black\"),\n  #                 text = matrix(paste0(\"<br>Classif:\",\n  #                                      class,\n  #                                      \"<br>Prob. error:\",\n  #                                      round(1-tikmax, 3)), nrow(z), ncol(z))) %>%\n  #     layout( xaxis= xaxis, yaxis=yaxis)\n  #   p\n  #   if (add.iso)\n  #     p <-  add_contour(p,\n  #                       z = 10*(z>tmp$minimum),\n  #                       x=xval,\n  #                       y=yval,\n  #                       hoverinfo = 'none',\n  #                       colors=colorRamp(c(\"black\", \"black\")),\n  #                       ncontours = 20,\n  #                       showscale=FALSE ,\n  #                       contours=list(coloring=\"heatmap\"),\n  #                       line=list(color=\"black\", dash=\"dot\"))%>%\n  #     add_trace(p,\n  #               x=res$centers[,dim[1]],\n  #               y=res$centers[,dim[2]],\n  #               type=\"scatter\",\n  #               mode=\"text\",\n  #               hoverinfo = 'none',\n  #               textfont = list(color = 'red',\n  #                               family = 'sans serif',\n  #                               size = 16,\n  #                               font = \"white\"),\n  #               text=as.character(1:nrow(res$centers)))%>%\n  #     add_trace(p,\n  #               x=res$centers[,dim[1]],\n  #               y=res$centers[,dim[2]],\n  #               type=\"scatter\",\n  #               opacity=0,\n  #               mode=\"markers\",\n  #               hoverinfo = 'text',\n  #               text = paste0(\"Center of Class \",\n  #                             1:nrow(res$centers),\n  #                             \"<br>Dim\", dim[1], \": \", round(res$centers[,dim[1]], 2),\n  #                             \"<br>Dim\", dim[2], \": \", round(res$centers[,dim[2]], 2))\n  #     )\n  #\n  #\n  #   if (add.obs)\n  #     p <- add_trace(p,\n  #                    x=res$y[,dim[1]],\n  #                    y=res$y[,dim[2]],\n  #                    type=\"scatter\",\n  #                    mode=\"text\",\n  #                    hoverinfo = 'none',\n  #                    textfont = list(color = apply(res$logtik.obs, 1, which.max),\n  #                                    family = 'sans serif',\n  #                                    size = 10,\n  #                                    font = \"white\"),\n  #                    text=as.character(apply(res$logtik.obs, 1, which.max))) %>%\n  #     add_trace(p,\n  #               x=res$y[,dim[1]],\n  #               y=res$y[,dim[2]],\n  #               type=\"scatter\",\n  #               marker=list(color=\"blue\"),\n  #               opacity=0,\n  #               mode=\"markers\",\n  #               hoverinfo = 'text',\n  #               text = paste0(\"Obs:     \",\n  #                             1:nrow(res$y),\n  #                             \"<br>Classif.:\",\n  #                             apply(res$logtik.obs, 1, which.max),\n  #                             \"<br>Prob. error:\",\n  #                             round(1-apply(exp(res$logtik.obs), 1, max), 3)))\n  #   p\n  # }\n  #\n\n\n  # plotDensityClusVisu <- function(res,\n  #                                 dim=c(1,2),\n  #                                 threshold=0.99,\n  #                                 add.obs=FALSE,\n  #                                 add.modes=TRUE){\n  # xval <- seq(min(c(res$centers[,dim[1]], res$y[,dim[1]]))-2, max(c(res$centers[,dim[1]], res$y[,dim[1]])) + 2, length.out = 200)\n  # yval <- seq(min(c(res$centers[,dim[2]], res$y[,dim[2]]))-2, max(c(res$centers[,dim[2]], res$y[,dim[2]])) + 2, length.out = 200)\n  #\n  # tmp <- sapply(1:length(res$prop), function(k) as.numeric(outer(xval, yval, dmixtmvnorm, mu=res$centers[k,dim], prop=res$prop[k])))\n  # z <- t(matrix(rowSums(tmp), length(xval), length(yval)))\n  # tikmax <- t(matrix(apply(sweep(tmp, 1, rowSums(tmp), \"/\"), 1, max), length(xval), length(yval)))\n  # class <- t(matrix(apply(sweep(tmp, 1, rowSums(tmp), \"/\"), 1, which.max), length(xval), length(yval)))\n  # tmp <- optimize(function(alpha, z, threshold) abs(sum(z*(z>alpha))/sum(z) - threshold),\n  #                 interval = c(0, max(z)),\n  #                 z=z,\n  #                 threshold=threshold)\n  # bound <- min(as.numeric(tikmax)[which(as.numeric(z)>tmp$minimum)])\n  #\n  # area <- (z>tmp$minimum) * (tikmax - bound) + (z>tmp$minimum) * 0.1\n  #\n  # f <- list(\n  #   family = \"sans serif\",\n  #   size = 14,\n  #   color = \"black\"\n  # )\n  #\n  # a <- list(\n  #   x = res$centers[,dim[1]],\n  #   y = res$centers[,dim[2]],\n  #   text = 1:nrow(res$centers),\n  #   xref = \"x\",\n  #   yref = \"y\",\n  #   showarrow = F,\n  #   ax = 0,\n  #   ay = 0,\n  #   font = list(color = 'red',\n  #               family = 'sans serif',\n  #               size = 16,\n  #               font = \"white\")\n  # )\n  #\n  # xaxis <- list(\n  #   title = paste0(\"Dim1 (\", 100*round(res$inertia[dim[1]]/sum(res$inertia), 4), \"%)\"),\n  #   titlefont = f\n  # )\n  # yaxis <- list(\n  #   title = paste0(\"Dim2 (\", 100*round(res$inertia[dim[2]]/sum(res$inertia), 4), \"%)\"),\n  #   titlefont = f\n  # )\n  # p <- plot_ly(data=as.data.frame(res$y)) %>%\n  #   add_contour(z = area,\n  #               x=xval,\n  #               y=yval,\n  #               type = \"contour\",\n  #               colors = colorRamp(c(\"white\", \"grey30\")),\n  #               hoverinfo = 'text',\n  #               ncontours = 20,\n  #               showscale=FALSE ,\n  #               text = matrix(paste0(\"log-density:     \",\n  #                                    round(log(z),3),\n  #                                    \"<br>Classif:\",\n  #                                    class,\n  #                                    \"<br>Proportion:\",\n  #                                    round(res$prop[as.numeric(class)],2),\n  #                                    \"<br>Prob. error:\",\n  #                                    round(1-tikmax, 3)), nrow(z), ncol(z))) %>%\n  #   layout( annotations = a, xaxis= xaxis, yaxis=yaxis)\n  #   if (add.obs)\n  #     p <- add_trace(p,\n  #                    x=res$y[,dim[1]],\n  #                    y=res$y[,dim[2]],\n  #                    type=\"scatter\",\n  #                    marker=list(color=\"blue\"),\n  #                    mode=\"markers\",\n  #                    hoverinfo = 'text',\n  #                    text = paste0(\"Obs:     \",\n  #                                  1:nrow(res$y),\n  #                                  \"<br>Classif.:\",\n  #                                  apply(res$logtik.obs, 1, which.max),\n  #                                  \"<br>Prob. error:\",\n  #                                  round(1-apply(exp(res$logtik.obs), 1, max), 3)))\n  #\n  #   if (add.modes)\n  #     p <- add_trace(p,\n  #                    x=res$modes[,dim[1]],\n  #                    y=res$modes[,dim[2]],\n  #                    type=\"scatter\",\n  #                    marker=list(color=\"red\"),\n  #                    mode=\"markers\")\n  #\n  #   p\n  #\n  # }\n\n#\n#   plotDensityClusVisu <- function(res,\n#                                   add.centers=FALSE,\n#                                   threshold=.8,\n#                                   dim=c(1,2),\n#                                   col.dots=res$partition$hard,\n#                                   col.centers=1,\n#                                   cex.dots=0.8,\n#                                   lwd.dots=0.9,...){\n#     n <- 4 * (10**2)\n#     rangey1 <- range(c(res$centers[,dim[1]], res$y[,dim[1]])) + c(-2, 2)\n#     rangey2 <- range(c(res$centers[,dim[2]], res$y[,dim[2]])) + c(-2, 2)\n#     input <- list(x=(seq(rangey1[1], rangey1[2], length.res = n)), y=(seq(rangey2[1], rangey2[2], length.res = n)))\n#     input$z <- reser(input$x,\n#                      input$y,\n#                      function(x, y, centers, prop){\n#                        res <- matrix(sapply(1:nrow(centers),\n#                                             function(k) dnorm(x, centers[k,dim[1]], log=TRUE) + dnorm(y, centers[k,dim[2]], log=TRUE) + log(prop[k])), ncol=nrow(centers))\n#                        res <- exp(sweep(res, 1, apply(res, 1, max), \"-\"))\n#                        res <- sweep(res, 1, rowSums(res), \"/\")\n#\n#                        return(apply(res, 1, max))\n#                      },\n#                      centers=res$centers, prop=res$prop)\n#     threshold <- sort(threshold, decreasing = F)\n#     input$zthreshold <- input$z * 0\n#     for (h in 1:length(threshold))  input$zthreshold <- input$zthreshold + (input$z>threshold[h])\n#     image(input$x, input$y, input$zthreshold, col=c(\"white\",paste0(\"gray\", floor(50 + (1-threshold)*50))),\n#           xlab=paste0(\"Dim1 (\", 100*round(res$inertia[dim[1]]/sum(res$inertia), 4), \"%)\") ,\n#           ylab=paste0(\"Dim2 (\", 100*round(res$inertia[dim[2]]/sum(res$inertia), 4), \"%)\", ...))\n#     xlab=\"dim1\",\n#     ylab=\"dim2\", ...)\n# maxtik <- exp(apply(res$logtik.obs, 1, max))\n# maxtik <- (maxtik - 1/ncol(res$logtik.obs)) / (1-1/ncol(res$logtik.obs))\n# colo <- rep(\"gray10\", length(maxtik))\n# if (any(maxtik>threshold)) colo[which(maxtik > threshold)] <- \"gray70\"\n# plot(res$y, pch=20,#14+apply(res$logtik.obs, 1, which.max),\n#      cex=cex.dots,\n#      lwd=lwd.dots,\n#      col=  colo,\n#      xlab=paste0(\"Dim1 (\", 100*round(res$inertia[dim[1]]/sum(res$inertia), 4), \"%)\") ,\n#      ylab=paste0(\"Dim2 (\", 100*round(res$inertia[dim[2]]/sum(res$inertia), 4), \"%)\"), ...)\n# res$centersy <- res$centers * 0\n# for (k in 1:nrow(res$centers)){\n#   res$centersy[k,] <- t(res$y) %*% as.numeric(exp(res$logtik.obs[,k])) / sum(exp(res$logtik.obs[,k]))\n# }\n# points(res$centersy[,1], res$centersy[,2], pch=22, col=\"black\", bg=\"white\", cex=1.8)\n# text(res$centersy[,1], res$centersy[,2], 1:nrow(res$centers), cex=0.7)\n#contour(input, levels = threshold, add=TRUE, labcex=.8)\n#if (add.centers) points(res$centers, pch=14 + (1:ncol(res$logtik.obs)), cex=2, col=col.centers, lwd=2)\n\n# if (add.obs) points(res$y, pch=14+apply(res$logtik.obs, 1, which.max), cex=cex.dots,\n#                     col=  paste0(\"gray\", ceiling( .8*(100 - maxtik*100))))\n\n\n",
    "created" : 1498227466616.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3366355490",
    "id" : "A1673FA3",
    "lastKnownWriteTime" : 1498229596,
    "last_content_update" : 1498229596177,
    "path" : "~/Documents/recherche/visualisation/clusvis/pkg/R/plot.R",
    "project_path" : "pkg/R/plot.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}