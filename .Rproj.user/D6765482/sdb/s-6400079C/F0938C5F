{
    "collab_server" : "",
    "contents" : "\n##' Variable Selection in model-based clustering managed by the Latent Class Model for analysis mixed-type data with missing values.\n##'\n##' The package uses a finite mixture model for analyzing mixed-type data (data with continuous and/or count and/or categorical variables) with missing values (missing at random) by assuming independence between classes. The one-dimensional marginals of the components follow standard distributions for facilitating both the model interpretation and the model selection. The variable selection is led by an alternated optimization procedure for maximizing the MICL criterion. The maximum likelihood inference is done by an EM algorithm for the selected model. This package also performs the imputation of missing values.\n##'\n##' \\tabular{ll}{\n##'   Package: \\tab VarSelLCM\\cr \n##'   Type: \\tab Package\\cr \n##'   Version: \\tab 2.0.0\\cr\n##'   Date: \\tab 2016-04-18\\cr \n##'   License: \\tab GPL-2\\cr \n##'   LazyLoad: \\tab yes\\cr\n##'   URL:  \\tab http://varsellcm.r-forge.r-project.org/\\cr\n\n##' }\n##'\n##' The main functions to use are \\link{VarSelCluster} and \\link{VarSelImputation.}\n##' \n##' Function \\link{VarSelCluster} carries out the model selection by maximizing the MICL criterion, then it performs the maximum likelihood estimation of the selected model via an EM algorithm.\n##' \n##' Function \\link{VarSelImputation} performs the imputation of missing values by taking the expectation of the missing values conditionally on the model, its parameters and on the observed variables.\n##' \n##' Tool methods \\link{summary}, \\link{print} and \\link{plot} are available for facilitating the interpretation.\n##' \n##' @name VarSelLCM-package\n##' @aliases VarSelLCM\n##' @rdname VarSelLCM-package\n##' @docType package\n##' @keywords package\n##' @import parallel\n##' @import Rcpp\n##' @import methods\n##' @importFrom mgcv uniquecombs\n##' @importFrom stats runif\n##' @useDynLib VarSelLCM\n##'\n##' @author\n##' Matthieu Marbac and Mohammed Sedki Maintainer: Mohammed Sedki <mohammed.sedki@u-psud.fr>\n##'\n##' @references M. Marbac and M. Sedki (2015). Variable selection for model-based clustering using the integrated completed-data likelihood. Preprint.\n##' \n##' @examples\n##' \\dontrun{\n##' # Package loading\n##' require(VarSelLCM)\n##' \n##' # Data loading:\n##' # x contains the observed variables\n##' # z the known statu (i.e. 1: absence and 2: presence of heart disease)\n##' data(heart)\n##' z <- heart[,\"Class\"]\n##' x <- heart[,-13]\n##' \n##' # Cluster analysis without variable selection\n##' res_without <- VarSelCluster(x, 2, vbleSelec = FALSE)\n##' \n##' # Cluster analysis with variable selection (with parallelisation)\n##' res_with <- VarSelCluster(x, 2, nbcores = 2, initModel=40)\n##' \n##' # Confusion matrices: variable selection decreases the misclassification error rate\n##' print(table(z, res_without@partitions@zMAP))\n##' print(table(z, res_with@partitions@zMAP))\n##' \n##' # Summary of the best model\n##' summary(res_with)\n##' \n##' # Parameters of the best model\n##' print(res_with)\n##' \n##' # Plot of the best model\n##' plot(res_with)\n##' \n##' }\n##' \nNULL\n\n\n###################################################################################\n##' This function performs the variable selection and the maximum likelihood estimation of the Latent Class Model\n##'\n##' @param x data.frame. Rows correspond to observations and columns correspond to variables. Continuous variables must be \"numeric\", count variables must be \"integer\" and categorical variables must be \"factor\".\n##' @param g numeric. It defines number of components.\n##' @param vbleSelec logical. It indicates if a variable selection is done (TRUE: yes, FALSE: no; default is 1).\n##' @param crit.varsel character. It defines the information criterion used for the variable selection (\"AIC\", \"BIC\" or \"MICL\"; only used if vbleSelec=1; default is \"BIC\").\n##' @param initModel numeric. It gives the number of initializations of the alternated algorithm maximizing the MICL criterion (only used if crit.varsel=\"MICL\"; default is 50)\n##' @param nbcores numeric.  It defines the numerber of cores used by the alogrithm (default is 1).\n##' @param discrim numeric. It indicates if each variable is discrimiative (1) or irrelevant (0) (only used if vbleSelec=0; default is rep(1,ncol(x))).\n##' @param nbSmall numeric. It indicates  the number of SmallEM algorithms performed for the ML inference (default is 250).\n##' @param iterSmall numeric. It indicates  the number of iterations for each SmallEM algorithm (default is 20).\n##' @param nbKeep numeric. It indicates the number of chains used for the final EM algorithm (default is 50).\n##' @param iterKeep numeric. It indicates the maximal number of iterations for each EM algorithm (default is 1000).\n##' @param tolKeep numeric. It indicates the maximal gap between two successive iterations of EM algorithm which stops the algorithm (default is 0.001).\n##' \n##'  \n##' @return Returns an instance of \\linkS4class{VSLCMresultsMixed}.\n##' @examples\n##' \\dontrun{\n##' data(iris)\n##' res.LCM <- VarSelCluster(x, 2)\n##' summary(res.LCM)\n##' }\n##' @export\n##'\n##'\nVarSelCluster <- function(x, g, vbleSelec=TRUE, crit.varsel=\"BIC\", initModel=50,  nbcores=1, discrim=rep(1,ncol(x)), nbSmall=250, iterSmall=20,  nbKeep=50, iterKeep=1000, tolKeep=10**(-6)){\n  reference <- BuildS4Reference(x, g, initModel, vbleSelec, crit.varsel, TRUE, nbcores, discrim, nbSmall, iterSmall, nbKeep, iterKeep, tolKeep)\n  if (g==1){\n    reference <- withoutmixture(reference)\n  }else{\n    # Estimation du modele et/ou des parametres\n    if (reference@strategy@parallel == FALSE)\n      reference <- VarSelModelMLE(reference, 0)\n    else{\n      reference <- ParallelCriterion(reference, min(reference@strategy@initModel, nbcores))\n      reference@strategy@vbleSelec <- vbleSelec\n    }    \n  }\n  return(DesignOutput(reference))\n}\n\nParallelCriterion <- function(reference, nb.cpus){\n  if (reference@strategy@vbleSelec==FALSE){\n    reference@strategy@paramEstim <- TRUE\n    reference@strategy@nbSmall <- ceiling(reference@strategy@nbSmall / nb.cpus)\n    reference@strategy@nbKeep <- ceiling(reference@strategy@nbKeep / nb.cpus)\n    if(Sys.info()[\"sysname\"] == \"Windows\"){\n      cl <- makeCluster(nb.cpus)\n      common.objects <- c(\"reference\",\"VarSelModelMLE\", \"OptimizeMICL\")\n      clusterEvalQ(cl, {require(VarSelLCM)})\n      clusterExport(cl=cl, varlist = common.objects, envir = environment())\n      reference <- parLapply(cl = cl, X  = as.list(rep(0, nb.cpus)), fun = function(g){VarSelModelMLE(reference,g)})\n      stopCluster(cl)\n    }else{\n      reference <- mclapply(X = as.list(rep(0, nb.cpus)), FUN = VarSelModelMLE, obj=reference, mc.cores = nb.cpus)\n    }\n    # On conserve les parametres maximisant la vraisemblance\n    tmploglike <- rep(NA, length(reference))\n    for (it in 1:length(tmploglike)) {if (reference[[it]]@criteria@degeneracyrate!=1) tmploglike[it] <- reference[[it]]@criteria@loglikelihood}\n    if (all(is.na(tmploglike))) tmploglike[1]=1\n    reference <- reference[[which.max(tmploglike)]]\n  }else{\n    if (reference@strategy@crit.varsel==\"MICL\"){\n      reference@strategy@paramEstim <- FALSE\n      reference@strategy@initModel <- ceiling(reference@strategy@initModel / nb.cpus)       \n      if(Sys.info()[\"sysname\"] == \"Windows\"){\n        cl <- makeCluster(nb.cpus)\n        common.objects <- c(\"reference\",\"VarSelModelMLE\", \"OptimizeMICL\")\n        clusterEvalQ(cl, {require(VarSelLCM)})\n        clusterExport(cl=cl, varlist = common.objects, envir = environment())\n        reference <- parLapply(cl = cl, X  = as.list(rep(0, nb.cpus)), fun = function(g){VarSelModelMLE(reference,g)})\n        stopCluster(cl)          \n      }else{\n        reference <- mclapply(X = as.list(rep(0, nb.cpus)), FUN = VarSelModelMLE, obj=reference, mc.cores = nb.cpus)\n      }\n      # On conserve le meilleur modele au sens de MICL\n      tmpMICL <- rep(NA, length(reference))\n      for (it in 1:length(reference)) tmpMICL[it] <- reference[[it]]@criteria@MICL\n      cvrate <- 0\n      for (it in which(tmpMICL==max(tmpMICL))) cvrate <- cvrate + reference[[it]]@criteria@cvrate\n      reference <- reference[[which.max(tmpMICL)]]\n      reference@criteria@cvrate <- cvrate\n      reference@strategy@paramEstim <- TRUE\n      reference@strategy@vbleSelec <- FALSE\n      reference <- ParallelCriterion(reference, nb.cpus)\n    }else{\n      reference@strategy@initModel <- ceiling(reference@strategy@initModel / nb.cpus)       \n      if(Sys.info()[\"sysname\"] == \"Windows\"){\n        cl <- makeCluster(nb.cpus)\n        common.objects <- c(\"reference\",\"VarSelModelMLE\", \"OptimizeMICL\")\n        clusterEvalQ(cl, {require(VarSelLCM)})\n        clusterExport(cl=cl, varlist = common.objects, envir = environment())\n        reference <- parLapply(cl = cl, X  = as.list(rep(0, nb.cpus)), fun = function(g){VarSelModelMLE(reference,g)})\n        stopCluster(cl)          \n      }else{\n        reference <- mclapply(X = as.list(rep(0, nb.cpus)), FUN = VarSelModelMLE, obj=reference, mc.cores = nb.cpus)\n      }\n      tmpIC <- rep(NA, length(reference))\n      if (reference[[1]]@strategy@crit.varsel==\"BIC\") for (it in 1:length(reference)) tmpIC[it] <- reference[[it]]@criteria@BIC\n      if (reference[[1]]@strategy@crit.varsel==\"AIC\") for (it in 1:length(reference)) tmpIC[it] <- reference[[it]]@criteria@AIC\n      reference <- reference[[which.max(tmpIC)]]\n    }\n  }\n  reference\n}\n\n\nBuildS4Reference <- function(x, g, initModel, vbleSelec, crit.varsel, paramEstim, nbcores, discrim, nbSmall, iterSmall, nbKeep, iterKeep, tolKeep){\n  CheckInputs(x, g, initModel, vbleSelec, crit.varsel, discrim, paramEstim, nbcores, nbSmall, iterSmall, nbKeep, iterKeep, tolKeep)\n  # Creation de l'objet S4 VSLCMstrategy contenant les parametres de reglage\n  strategy <- VSLCMstrategy(initModel, nbcores, vbleSelec, crit.varsel, paramEstim, nbSmall, iterSmall, nbKeep, iterKeep, tolKeep)    \n  # Creation de l'objet S4 VSLCMdataContinuous ou VSLCMdataCategorical\n  if ((vbleSelec==FALSE) || (crit.varsel==\"MICL\"))\n    data <- VSLCMdata(x)\n  else\n    data <- VSLCMdataMixte(x)  \n  if (class(data) == \"VSLCMdataContinuous\")\n    reference <- new(\"VSLCMresultsContinuous\", data=data, criteria=InitCriteria(), model=new(\"VSLCMmodel\",g=g, omega=discrim), strategy=strategy)\n  else if (class(data) == \"VSLCMdataInteger\")\n    reference <- new(\"VSLCMresultsInteger\", data=data, criteria=InitCriteria(), model=new(\"VSLCMmodel\",g=g, omega=discrim), strategy=strategy)\n  else if (class(data) == \"VSLCMdataCategorical\")\n    reference <- new(\"VSLCMresultsCategorical\", data=data, criteria=InitCriteria(), model=new(\"VSLCMmodel\",g=g, omega=discrim), strategy=strategy)\n  else if (class(data) == \"VSLCMdataMixed\")\n    reference <- new(\"VSLCMresultsMixed\", data=data, criteria=InitCriteria(), model=new(\"VSLCMmodel\",g=g, omega=discrim), strategy=strategy)\n  else\n    stop(\"Problem in the data!\")      \n  return(reference)\n}\n\nParallelMICL <- function(reference, nb.cpus){\n  if (reference@strategy@crit.varsel == TRUE){\n      }\n  \n  return(reference)\n}\n########################################################################################################################\n## Fonctions principales du package, les seules accessibles par l'utilisateur sont VarSelCluster,\n## Imputation (voir Imputation.R) et MICL\n########################################################################################################################\nsetGeneric ( name= \"MICL\",  def = function(x, obj){ standardGeneric(\"MICL\")})\n## Pour les variables continues\nsetMethod( f = \"MICL\", \n           signature(x=\"data.frame\", obj=\"VSLCMresultsContinuous\"), \n           definition = function(x, obj){\n             obj@strategy@crit.varsel <- TRUE\n             obj@data  <- VSLCMdata(x)\n             tmp <- ComputeMICL(obj, \"Continuous\")\n             return(list(MICL=tmp@criteria@MICL, zOPT=tmp@partitions@zOPT+1))         \n           }\n)\n## Pour les variables entieres\nsetMethod( f = \"MICL\", \n           signature(x=\"data.frame\", obj=\"VSLCMresultsInteger\"), \n           definition = function(x, obj){\n             obj@strategy@crit.varsel <- TRUE\n             # travail sur les donnees manquantes\n             obj@data  <- VSLCMdata(x)\n             tmp <- ComputeMICL(obj, \"Integer\")\n             return(list(MICL=tmp@criteria@MICL, zOPT=tmp@partitions@zOPT+1))          \n           }\n)\n## Pour les variables categorielles\nsetMethod( f = \"MICL\", \n           signature(x=\"data.frame\", obj=\"VSLCMresultsCategorical\"), \n           definition = function(x, obj){\n             obj@strategy@crit.varsel <- TRUE\n             obj@data  <- VSLCMdata(x)\n             tmp <- ComputeMICL(obj, \"Categorical\")\n             tmp@partitions@zOPT <-  1 + as.numeric(obj@partitions@zOPT[attr(obj@data@shortdata,\"index\")])\n             return(list(MICL=tmp@criteria@MICL, zOPT=tmp@partitions@zOPT))       \n           }\n)\n## Pour les variables mixed\nsetMethod( f = \"MICL\", \n           signature(x=\"data.frame\", obj=\"VSLCMresultsMixed\"), \n           definition = function(x, obj){\n             obj@strategy@crit.varsel <- TRUE\n             obj@data  <- VSLCMdata(x)\n             tmp <- ComputeMICL(obj, \"Mixed\")\n             return(list(MICL=tmp@criteria@MICL, zOPT=tmp@partitions@zOPT+1))     \n           }\n)\n\n\n########################################################################################################################\n## La fonction VarSelModelMLE permet d'effectuer l'estimation des parametres en considerant que les variables donnees\n## dans le slot model de l'objet VSLCMresultsContinuous ou VSLCMresultsCategorical.\n## Il appelle le code c++ et retourne un objet VSLCMresultsContinuous ou VSLCMresultsCategorical en fonction de la\n## nature des donnees.\n########################################################################################################################\nsetGeneric ( name= \"VarSelModelMLE\",  def = function(obj,it){ standardGeneric(\"VarSelModelMLE\")})\n## Pour les variables continues\nsetMethod( f = \"VarSelModelMLE\", \n           signature(obj=\"VSLCMresultsContinuous\",it=\"numeric\"), \n           definition = function(obj,it){\n             if ((obj@strategy@vbleSelec==FALSE)||(obj@strategy@crit.varsel==\"MICL\")){\n               reference <- OptimizeMICL(obj, \"Continuous\")               \n             }else{\n               stop(\"error\")\n             }\n             return(reference)         \n           }\n)\n## Pour les variables entiers\nsetMethod( f = \"VarSelModelMLE\", \n           signature(obj=\"VSLCMresultsInteger\",it=\"numeric\"), \n           definition = function(obj,it){\n             if ((obj@strategy@vbleSelec==FALSE)||(obj@strategy@crit.varsel==\"MICL\")){\n               reference <- OptimizeMICL(obj, \"Integer\")\n             }else{\n               stop(\"error\")\n             }\n             return(reference)         \n           }\n)\n## Pour les variables categorielles\nsetMethod( f = \"VarSelModelMLE\", \n           signature(obj=\"VSLCMresultsCategorical\",it=\"numeric\"), \n           definition = function(obj, it){\n             if ((obj@strategy@vbleSelec==FALSE)||(obj@strategy@crit.varsel==\"MICL\")){\n               reference <- OptimizeMICL(obj, \"Categorical\")\n             }else{\n               stop(\"error\")\n             }\n             return(reference)           \n           }\n)\n## Pour les variables mixed\nsetMethod( f = \"VarSelModelMLE\", \n           signature(obj=\"VSLCMresultsMixed\",it=\"numeric\"), \n           definition = function(obj, it){\n             if ((obj@strategy@vbleSelec==FALSE)||(obj@strategy@crit.varsel==\"MICL\")){\n               reference <- OptimizeMICL(obj, \"Mixed\")\n             }else{\n               pen <- 0\n               if (obj@strategy@crit.varsel==\"AIC\") pen <- 1\n               if (obj@strategy@crit.varsel==\"BIC\") pen <- 0.5*log(obj@data@n)\n               reference <- OptimizePenLike(obj, pen)\n             }\n             return(reference)           \n           }\n)\n\n",
    "created" : 1498231117086.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2773399288",
    "id" : "F0938C5F",
    "lastKnownWriteTime" : 1482921776,
    "last_content_update" : 1482921776,
    "path" : "~/Documents/recherche/selection_variables_mixtes_et_manquantes/varsellcm/pkg/R/VarSelLCM.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}