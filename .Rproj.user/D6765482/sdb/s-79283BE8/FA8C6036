{
    "collab_server" : "",
    "contents" : "###################################################################################\n##' Function for visualizing the clustering results\n##'\n##' @param res object return by function \\link{clusvis} or \\link{clusvis}\n##' @param dim   numeric. This vector of size two choose the axes to represent.\n##' @param threshold   numeric. It contains the thersholds used for computing the level curves.\n##' @param add.obs   boolean. If TRUE, coordinnates of the observations are plotted.\n##' @param positionlegend  character. It specifies the legend location.\n##' @param xlim  numeric. It specifies the range of x-axis.\n##' @param ylim  numeric. It specifies the range of y-axis.\n##'\n##'\n##' @return NULL\n##' @examples\n##' \\dontrun{\n##' # Package loading\n##' require(Rmixmod)\n##' \n##' # Data loading (categorical data)\n##' data(birds)\n##'\n##' # Model-based clustering with 3 components\n##' resmixmod <- mixmodCluster(birds, 3)\n##'\n##' # Inference of the parameters used for results visualization\n##' # (specific for Rmixmod results)\n##' resvisu <- clusvisMixmod(resmixmod)\n##'\n##' # Component interpretation graph\n##' plotDensityClusVisu(resvisu)\n##'\n##' # Scatter-plot of the observation memberships\n##' plotDensityClusVisu(resvisu,  add.obs = TRUE)\n##' }\n##' @export\n##'\nplotDensityClusVisu <- function(res,\n                                dim=c(1,2),\n                                threshold=0.95,\n                                add.obs=FALSE,\n                                positionlegend=\"topright\",\n                                xlim=NULL,\n                                ylim=NULL){\n  if (res$error){\n   warning(\"The number of components must be at least 3 to use this function\") \n  }else{\n    if (add.obs){\n      input <- list()\n      if (is.null(xlim)) xlim <- c(min(c(res$centers[,dim[1]], res$y[,dim[1]]))-1, max(c(res$centers[,dim[1]], res$y[,dim[1]])) + 1)\n      if (is.null(ylim)) ylim <- c(min(c(res$centers[,dim[2]], res$y[,dim[2]]))-1, max(c(res$centers[,dim[2]], res$y[,dim[2]])) + 1)\n      input$xval <- seq(xlim[1], xlim[2], length.out = 400)\n      input$yval <- seq(ylim[1], ylim[2], length.out = 400)\n      tmp <- sapply(1:length(res$prop), function(k) as.numeric(outer(input$xval, input$yval, dmixtmvnorm, mu=res$centers[k,dim], prop=res$prop[k])))\n      input$z  <- t(matrix(rowSums(tmp), length(input$xval), length(input$yval)))\n      input$z <- (matrix(apply(sweep(tmp, 1, rowSums(tmp), \"/\"), 1, max), length(input$xval), length(input$yval)))\n      input$z[which(input$z<0.55)] <- 0.4\n      contour(input,\n              main = paste0(\"Difference between entropies: \", round(res$EM - res$EV,2)),\n              levels=c(0.95,0.8,0.5),\n              col=c(\"gray30\",\"gray30\",1),\n              lwd=c(1,1,2),\n              lty=c(2,2,1),\n              labcex = 0.8,\n              xlab=paste0(\"Dim1 (\", 100*round(res$inertia[dim[1]]/sum(res$inertia), 4), \"%)\"),\n              ylab=paste0(\"Dim2 (\", 100*round(res$inertia[dim[2]]/sum(res$inertia), 4), \"%)\"))\n      colset <- c(\"darkorange1\", \"dodgerblue2\", \"black\", \"chartreuse2\", \"darkorchid2\", \"gold2\", \"deeppink2\", \"deepskyblue1\", \"firebrick2\", \"cyan1\")\n      if (length(colset) < ncol(res$logtik.obs)) colset <- rep(\"black\", ncol(res$logtik.obs))\n      points(res$y[,dim[1]],\n             res$y[,dim[2]],\n             pch=20,\n             cex=0.7,\n             col=colset[apply(res$logtik.obs, 1, which.max)])\n      if (length(colset) >= ncol(res$logtik.obs)) legend(x = positionlegend, legend = paste0(\"Compo.\", 1:ncol(res$logtik.obs)), col = colset[1:ncol(res$logtik.obs)], pch = 20)\n      \n      \n    }else{\n      if (is.null(xlim)) xlim <- c(min(res$centers[,dim[1]])-4, max(res$centers[,dim[1]]) + 4)\n      if (is.null(ylim)) ylim <- c(min(res$centers[,dim[2]])-4, max(res$centers[,dim[2]]) + 4)\n      xval <- seq(xlim[1], xlim[2], length.out = 400)\n      yval <- seq(ylim[1], ylim[2], length.out = 400)\n      tmp <- sapply(1:length(res$prop), function(k) as.numeric(outer(xval, yval, dmixtmvnorm, mu=res$centers[k,dim], prop=res$prop[k])))\n      z <- t(matrix(rowSums(tmp), length(xval), length(yval)))\n      tikmax <- t(matrix(apply(sweep(tmp, 1, rowSums(tmp), \"/\"), 1, max), length(xval), length(yval)))\n      class <- t(matrix(apply(sweep(tmp, 1, rowSums(tmp), \"/\"), 1, which.max), length(xval), length(yval)))\n      tmp <- optimize(function(alpha, z, threshold) abs(sum(z*(z>alpha))/sum(z) - threshold),\n                      interval = c(0, max(z)),\n                      z=z,\n                      threshold=threshold)\n      bound <- min(as.numeric(tikmax)[which(as.numeric(z)>tmp$minimum)])\n      \n      tikmax <- tikmax *(z>tmp$minimum)\n      image(xval,yval,t(tikmax),\n            main =  paste0(\"Difference between entropies: \", round(res$EM - res$EV,2)),\n            col=c(\"white\",\"gray30\",\"gray60\",\"gray80\"), breaks = c(0,0.001,0.8,0.95,1),\n            xlab=paste0(\"Dim1 (\", 100*round(res$inertia[dim[1]]/sum(res$inertia), 4), \"%)\"),\n            ylab=paste0(\"Dim2 (\", 100*round(res$inertia[dim[2]]/sum(res$inertia), 4), \"%)\")\n      )\n      legend(legend = c(\"0.95<Pr. Classif.\", \"0.8<Pr. Classif.<0.95\", \"Pr. Classif.<0.8\", \"outside the conf. level.\"), x = positionlegend, fill = c(\"gray80\",\"gray60\",\"gray30\", \"white\"), cex=0.7)\n      input <- list(x=xval, y=yval, z=t(tikmax))\n      \n      contour(input, add=TRUE, levels=c(0.95,0.8,0.001), drawlabels = F,\n              lwd=c(1,1,2),\n              lty=c(2,2,1),\n              labcex = 0.8)\n      text(res$centers[,dim[1]], res$centers[,dim[2]], as.character(1:nrow(res$centers)), lwd=1.2)\n    }    \n  }\n}",
    "created" : 1499699702643.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1519965943",
    "id" : "FA8C6036",
    "lastKnownWriteTime" : 1499699411,
    "last_content_update" : 1499699411,
    "path" : "~/Documents/recherche/visualisation/clusvis/pkg/R/plot.R",
    "project_path" : "pkg/R/plot.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}